<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI News Reader, Summarizer, and Speaker</title>
    <style>
        /* Minimal CSS as requested, primarily for layout and readability */
        body {
            font-family: 'Inter', sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .myContainer {
            max-width: 800px;
            margin: auto;
            background-color: #fff;
            padding: 20px;
            border-radius: 10px; /* Using rounded corners as best practice */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #1a73e8;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h2 {
            color: #4CAF50;
            margin-top: 20px;
        }
        select, button, input[type="text"], textarea {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
            font-size: 16px;
        }
        .myControlGroup {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }
        .myControlGroup button {
            flex-grow: 1;
            width: auto;
        }
        #myStatus {
            font-weight: bold;
            padding: 10px;
            background-color: #e0f7fa;
            border-left: 5px solid #00bcd4;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        #mySummaryOutputArea {
            min-height: 200px;
            white-space: pre-wrap;
            font-family: monospace;
            background-color: #fafafa;
        }
    </style>
</head>
<body>

<div class="myContainer">
    <h1>AI-Powered News Summarizer & Speaker</h1>

    <div style="font-style: italic; margin-bottom: 20px; padding: 10px; background: #f0f0f0; border-radius: 5px;">
        <p><strong>Note:</strong> This app uses the experimental Chrome Built-in AI Summarizer API (`window.Summarizer`). You must enable the "Enable built-in AI" flag in Chrome to use the summarizer functionality. See the link at the bottom.</p>
    </div>

    <!-- Feeds Selection and Control -->
    <div class="myControlGroup">
        <label for="myFeedSelect" style="width: 100%; font-weight: bold; margin-bottom: 0;">Select News Feed:</label>
        <select id="myFeedSelect" onchange="myHandleUserFeedChange()" style="flex: 3;">
            <option value="">-- Choose a Feed --</option>
            <optgroup label="ðŸ‡¨ðŸ‡¦ Canadian General News">
                <option value="https://globalnews.ca/feed/">Global News - National</option>
                <option value="https://www.cbc.ca/webfeed/rss/rss-business">CBC News - Business</option>
                <option value="https://www.cbc.ca/webfeed/rss/rss-topstories">CBC News - Top Stories</option>
            </optgroup>
            <optgroup label="ðŸŒ World News & Politics">
                <option value="http://feeds.bbci.co.uk/news/world/rss.xml">BBC News - World</option>
                <option value="https://www.cbc.ca/webfeed/rss/rss-world">CBC News - World</option>
                <option value="https://www.theguardian.com/world/rss">The Guardian - World</option>
            </optgroup>
            <optgroup label="ðŸ”¬ Science & Technology">
                <option value="https://www.wired.com/feed/rss">WIRED - Latest Stories</option>
                <option value="https://www.cbc.ca/webfeed/rss/rss-technology">CBC News - Technology</option>
            </optgroup>
            <optgroup label="ðŸ’» Web Development">
                <option value="https://css-tricks.com/feed">CSS-Tricks</option>
            </optgroup>
        </select>
    </div>

    <!-- Auto Controls -->
    <div class="myControlGroup" style="gap: 20px;">
        <label style="display: flex; align-items: center; cursor: pointer; font-weight: bold;">
            <input type="checkbox" id="myAutoLoadCheckbox" style="width: auto; margin-right: 5px; margin-bottom: 0;">
            Auto Load Next Feed
        </label>
        <label style="display: flex; align-items: center; cursor: pointer; font-weight: bold;">
            <input type="checkbox" id="myAutoSpeakCheckbox" style="width: auto; margin-right: 5px; margin-bottom: 0;">
            Auto Speak Summaries
        </label>
    </div>

    <!-- Status and Output Area -->
    <h2>Status & Output</h2>
    <p id="myStatus">Ready. Select a feed to begin, or enable auto-load.</p>
    <textarea id="mySummaryOutputArea" readonly placeholder="Summaries will be appended here."></textarea>

    <!-- TTS Controls -->
    <h2>Text-to-Speech Controls</h2>
    <div class="myControlGroup">
        <select id="myVoiceSelect" style="flex: 2; margin-bottom: 0;"></select>
        <button id="mySpeakButton" onclick="mySpeakText()" style="flex: 1; color: white; background-color: #4CAF50; border: none;">Speak Output</button>
        <button id="myPauseButton" onclick="myPauseSpeech()" disabled style="flex: 1; color: white; background-color: #007bff; border: none;">Pause</button>
        <button id="myResumeButton" onclick="myResumeSpeech()" disabled style="flex: 1; color: white; background-color: #2196F3; border: none;">Resume</button>
        <button id="myStopButton" onclick="myStopSpeech()" disabled style="flex: 1; color: white; background-color: #dc3545; border: none;">Stop</button>
    </div>

    <!-- Chrome AI Flag Note -->
    <hr style="margin: 40px 0;">
    <div style="padding: 15px; border: 1px dashed #ccc; border-radius: 5px;">
        <h2>Chrome Flags Reminder</h2>
        <p>To use the Summarizer (AI) feature, copy and paste this link into your Chrome address bar, enable the flag, and restart the browser:</p>
        <input type="text" id="myFlagsLink" value="chrome://flags/#enable-built-in-ai" readonly
            style="cursor: pointer; background-color: #f0f0f0;"
            onclick="myCopyFlagsLink()">
    </div>
    
    <hr style="margin: 40px 0;">
    <div>
        <h2>My GitHub</h2>
        <p>You can find more of my work on my <a href="https://github.com/hpssjellis"> hpssjellis </a> GitHub page:</p>
        <p> By Jeremy Ellis <a href="https://ca.linkedin.com/in/jeremy-ellis-4237a9bb"> LinkedIn </a><br></p>
    </div>

</div>

<script>
    // =========================================================================
    // GLOBAL CONFIGURATION AND STATE
    // =========================================================================
    const myConverterUrl = 'https://api.rss2json.com/v1/api.json?rss_url=';
    const myMaxItemsToSummarize = 5; // Limit to 5 items per feed for speed

    let myTimerInterval = null;
    let mySummarizer = null; // Chrome Summarizer Object
    let myIsProcessing = false;

    // TTS Globals
    let mySpeechSynthesis = window.speechSynthesis;
    let myUtterance = null;

    // Auto-Load Globals
    let myAllFeedUrls = []; // Stores all selectable URLs for auto-looping
    let myCurrentFeedIndex = -1;

    // DOM Elements
    const myFeedSelect = document.getElementById('myFeedSelect');
    const mySummaryOutputArea = document.getElementById('mySummaryOutputArea');
    const myStatus = document.getElementById('myStatus');
    const myAutoLoadCheckbox = document.getElementById('myAutoLoadCheckbox');
    const myAutoSpeakCheckbox = document.getElementById('myAutoSpeakCheckbox');
    
    // TTS Buttons (defined in TTS section)
    const mySpeakButton = document.getElementById('mySpeakButton');
    const myPauseButton = document.getElementById('myPauseButton');
    const myResumeButton = document.getElementById('myResumeButton');
    const myStopButton = document.getElementById('myStopButton');
    const myVoiceSelect = document.getElementById('myVoiceSelect');


    // =========================================================================
    // UTILITY FUNCTIONS (Timer, Flags Link)
    // =========================================================================

    /**
     * Starts a simple timer to show activity.
     */
    function myStartTimer() {
        let mySeconds = 0;
        myStatus.textContent = "Working... 0s";
        myTimerInterval = setInterval(() => {
            mySeconds++;
            myStatus.textContent = `Working... ${mySeconds}s`;
        }, 1000);
    }

    /**
     * Stops the timer and sets the final status message.
     * @param {string} myMessage The final status message.
     */
    function myStopTimer(myMessage) {
        if (myTimerInterval) {
            clearInterval(myTimerInterval);
            myTimerInterval = null;
        }
        myStatus.textContent = myMessage;
    }

    /**
     * Helper function to copy the flags link.
     */
    function myCopyFlagsLink() {
        const myFlagsInput = document.getElementById('myFlagsLink');
        myFlagsInput.select();
        myFlagsInput.setSelectionRange(0, 99999);
        document.execCommand('copy'); 
    }

    // =========================================================================
    // TEXT-TO-SPEECH (TTS) LOGIC
    // =========================================================================

    /**
     * Sets the disabled/enabled state of the TTS control buttons.
     * @param {boolean} speaking True if speech is currently ongoing.
     * @param {boolean} paused True if speech is currently paused.
     */
    function mySetButtonStates(speaking, paused) {
        mySpeakButton.disabled = speaking || paused;
        myPauseButton.disabled = !speaking || paused;
        myResumeButton.disabled = !paused;
        myStopButton.disabled = !speaking && !paused;
    }

    /**
     * Populates the voice list dropdown with available browser voices.
     */
    function myPopulateVoiceList() {
        const myVoices = mySpeechSynthesis.getVoices();
        myVoiceSelect.innerHTML = '';
        myVoices.forEach(voice => {
            const myOption = document.createElement('option');
            myOption.textContent = `${voice.name} (${voice.lang})`;
            myOption.value = voice.name;
            myVoiceSelect.appendChild(myOption);
        });
        // Set initial button states
        mySetButtonStates(false, false);
    }

    // Call the function initially and also on the 'voiceschanged' event
    myPopulateVoiceList();
    if (mySpeechSynthesis.onvoiceschanged !== undefined) {
        mySpeechSynthesis.onvoiceschanged = myPopulateVoiceList;
    }

    /**
     * Speaks the text in the main output area.
     */
    function mySpeakText() {
        myStopSpeech(); // Stop any existing speech before starting a new one
        
        const myTextToSpeak = mySummaryOutputArea.value;
        if (!myTextToSpeak.trim()) {
            myStatus.textContent = 'Nothing to speak.';
            return;
        }

        myUtterance = new SpeechSynthesisUtterance(myTextToSpeak);

        // Set the voice
        const mySelectedVoiceName = myVoiceSelect.value;
        const mySelectedVoice = mySpeechSynthesis.getVoices().find(voice => voice.name === mySelectedVoiceName);
        if (mySelectedVoice) {
            myUtterance.voice = mySelectedVoice;
        }

        myUtterance.onstart = () => {
            myStatus.textContent = 'Speaking summaries...';
            mySetButtonStates(true, false);
        };

        myUtterance.onend = () => {
            myStatus.textContent = 'Finished speaking.';
            mySetButtonStates(false, false);
        };

        myUtterance.onerror = (event) => {
            myStatus.textContent = `Error speaking: ${event.error}`;
            mySetButtonStates(false, false);
            console.error('SpeechSynthesis Error:', event.error);
        };

        mySpeechSynthesis.speak(myUtterance);
    }

    /** Pauses the speech. */
    function myPauseSpeech() {
        if (mySpeechSynthesis.speaking) {
            mySpeechSynthesis.pause();
            myStatus.textContent = 'Paused.';
            mySetButtonStates(false, true);
        }
    }

    /** Resumes the speech. */
    function myResumeSpeech() {
        if (mySpeechSynthesis.paused) {
            mySpeechSynthesis.resume();
            myStatus.textContent = 'Speaking...';
            mySetButtonStates(true, false);
        }
    }

    /** Stops the speech. */
    function myStopSpeech() {
        mySpeechSynthesis.cancel();
        myStatus.textContent = myIsProcessing ? 'Processing feed...' : 'Ready.';
        mySetButtonStates(false, false);
    }


    // =========================================================================
    // CHROME AI SUMMARIZATION LOGIC
    // =========================================================================

    /**
     * Initializes the Chrome Summarizer object if not already created.
     */
    async function myInitializeSummarizer() {
        if (mySummarizer === null) {
            if (!('Summarizer' in window)) {
                throw new Error("Summarizer API (window.Summarizer) not found. Check Chrome version/flags.");
            }
            
            myStatus.textContent = "Initializing AI model (first time setup/download)...";
            const myOptions = {
                type: 'key-points', // Closest to 'main concept'
                length: 'medium',   // Relying on the output being a 'short quote'
                language: 'en',
            };
            mySummarizer = await Summarizer.create(myOptions);
        }
    }


    /**
     * Summarizes a single RSS item's content to a short quote and appends it to the output area.
     * @param {object} myItem The single RSS item object.
     */
    async function mySummarizeAndDisplayItem(myItem) {
        myStopTimer(`Summarizing: ${myItem.title.substring(0, 40)}...`);
        
        try {
            await myInitializeSummarizer();

            // Use the description, or fallback to content/title
            const myTextToSummarize = myItem.description || myItem.content || myItem.title;

            // Step 2: Perform summarization
            const mySummary = await mySummarizer.summarize(myTextToSummarize);
            
            // Format the output as required: very short quote + link
            const myFormattedEntry = `
--------------------------------------------------
> "${mySummary.trim()}"
> Source: ${myItem.title}
> Link: ${myItem.link}
--------------------------------------------------
`;
            mySummaryOutputArea.value += myFormattedEntry;

        } catch (myError) {
            console.error("Summarizer Error:", myError);
            mySummaryOutputArea.value += `\n[ERROR SUMMARIZING: ${myItem.title}] - ${myError.message.split('\n')[0]}\n`;
        }
    }


    // =========================================================================
    // RSS FEED PROCESSING & AUTO-LOOP LOGIC
    // =========================================================================

    /**
     * Fetches the RSS feed URL, converts it to JSON, and starts the summarization process.
     * @param {string} rssUrl The URL of the RSS feed to fetch.
     * @returns {void}
     */
    async function myFetchFeed(rssUrl) {
        myIsProcessing = true;
        mySummaryOutputArea.value = '';
        myStopSpeech(); // Stop speech if active

        const myApiUrl = myConverterUrl + encodeURIComponent(rssUrl);
        myStartTimer();
        myStatus.textContent = `Fetching feed: ${rssUrl}...`;

        try {
            const myResponse = await fetch(myApiUrl);
            if (!myResponse.ok) {
                throw new Error(`HTTP error! Status: ${myResponse.status}`);
            }

            const myJsonData = await myResponse.json();
            
            if (myJsonData.status === 'error') {
                 throw new Error(myJsonData.message || 'Error processing the feed.');
            }

            myStatus.textContent = `Processing ${myJsonData.feed.title}...`;
            
            const myItems = myJsonData.items || [];

            // Loop and summarize the first few items sequentially
            for (let i = 0; i < Math.min(myItems.length, myMaxItemsToSummarize); i++) {
                await mySummarizeAndDisplayItem(myItems[i]);
            }

            myStopTimer(`Feed '${myJsonData.feed.title}' processed. ${myItems.length} items found, ${Math.min(myItems.length, myMaxItemsToSummarize)} summarized.`);
            
            // Auto Speak Check
            if (myAutoSpeakCheckbox.checked) {
                mySpeakText();
            }

        } catch (myError) {
            console.error('Fetch/Processing error:', myError);
            myStopTimer(`Error loading feed: ${myError.message.split('\n')[0]}`);
            mySummaryOutputArea.value += `\n\n--- FEED ERROR ---\n${myError.message}`;
        } finally {
            myIsProcessing = false;
            
            // Auto Load Check (Always check after a manual change or a loop iteration)
            if (myAutoLoadCheckbox.checked && myCurrentFeedIndex !== -1) {
                 // Wait a few seconds before loading the next feed in auto mode
                 await new Promise(resolve => setTimeout(resolve, 3000));
                 myProcessFeedsLoop();
            }
        }
    }

    /**
     * Handles when the user manually changes the select box.
     */
    function myHandleUserFeedChange() {
        myStopSpeech();
        if (myIsProcessing) {
            myStatus.textContent = 'A feed is currently being processed. Please wait.';
            return;
        }

        const myRssUrl = myFeedSelect.value;
        if (myRssUrl) {
            // Find the index of the manually selected feed to start auto-looping from there
            myCurrentFeedIndex = myAllFeedUrls.indexOf(myRssUrl); 
            myFetchFeed(myRssUrl);
        } else {
            mySummaryOutputArea.value = 'Select a feed or enable "Auto Load" to begin.';
            myStatus.textContent = 'Ready.';
        }
    }
    
    /**
     * Handles the iterative logic for auto-loading the next feed.
     */
    function myProcessFeedsLoop() {
        if (!myAutoLoadCheckbox.checked || myIsProcessing) {
            return;
        }

        // If myCurrentFeedIndex is -1 (initial state), start from the beginning (0).
        // Otherwise, increment and wrap around.
        if (myCurrentFeedIndex === -1) {
            myCurrentFeedIndex = 0;
        } else {
            myCurrentFeedIndex = (myCurrentFeedIndex + 1) % myAllFeedUrls.length;
        }

        if (myAllFeedUrls.length > 0) {
            const myNextUrl = myAllFeedUrls[myCurrentFeedIndex];
            
            // Set the select box value to reflect the current auto-loaded feed
            myFeedSelect.value = myNextUrl;
            
            myFetchFeed(myNextUrl);
        } else {
            myStopTimer("No feeds available for auto-loading.");
        }
    }
    
    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initializes the list of all feed URLs for auto-looping.
     */
    function myInitializeFeedUrls() {
        myAllFeedUrls = Array.from(myFeedSelect.options)
                             .filter(option => option.value && option.value !== "")
                             .map(option => option.value);
    }
    
    // Initialize feed URL list on page load
    myInitializeFeedUrls();
    
    // Add event listener for auto-load checkbox to start the loop immediately if checked
    myAutoLoadCheckbox.onchange = function() {
        if (this.checked) {
            myProcessFeedsLoop();
        } else {
             // Reset index on manual stop
            myCurrentFeedIndex = myFeedSelect.value ? myAllFeedUrls.indexOf(myFeedSelect.value) : -1;
        }
    };

</script>

</body>
</html>
